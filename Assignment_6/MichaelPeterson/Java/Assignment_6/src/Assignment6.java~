import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributeView;
import java.nio.file.attribute.FileOwnerAttributeView;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.security.SecureRandom;

public class Assignment6 implements Runnable{

    private static String OS = System.getProperty("os.name").toLowerCase();
    private static final int STRING_INPUT_LENGTH = 50;
    private static final int INT_INPUT_LENGTH    = 11;
    private static final int PWD_INPUT_LENGTH    = 64;
    private static boolean TEST                  = true;

    File logFile;

    public static void main(String[] args) {
        (new Assignment6()).run();
    }


    private class RegexValidator{
        public String regex;
        public Boolean shouldMatch;
        public String failDescription;

        public RegexValidator(String inRegex, Boolean inShouldMatch, String inFailDescription){
            if(inRegex == null || inShouldMatch == null || inFailDescription == null)
                throw new NullPointerException();

            regex = inRegex;
            shouldMatch = inShouldMatch;
            failDescription = inFailDescription;
        }

        public Boolean validate(String input){
            Matcher matcher = Pattern.compile(regex).matcher(input);

            return shouldMatch == matcher.matches();
        }
    }

    private enum FileType{
        Input,
        Output
    }

    private enum UserInputStatus{
        Empty,
        WithinLimits,
        TooLarge
    }

    private class UserInputResult{
        String value;
        UserInputStatus status;

        public UserInputResult(String inValue, UserInputStatus inStatus){
            value = inValue;
            status = inStatus;
        }
    }

    @Override
    public void run() {
       // if (!(OS.indexOf("nix") >= 0 || OS.indexOf("nux") >= 0 || OS.indexOf("aix") > 0)) {
       //     System.err.println("This software is designed to be run on a Linux operating system.");
       //     System.exit(1);
       // }

        String firstName, lastName;


        // Files
        File inputFile, outputFile;

        logFile = new File("error.log");
        if(!logFile.exists()) {
            try {
                logFile.createNewFile();
            }
            catch(Exception e){
                System.err.println(e.getMessage());
                System.exit(1);
            }
        }

        if(!logFile.canWrite()){
            System.err.println("Unable to write to log file \"error.log\"");
            System.exit(1);
        }



        // regexes
        String nameRegex = "^[a-zA-Z]{1,}$";
        String numberRegex = "^(()|\\+|\\-)[0-9]{1,10}$";
        String filenameRegex_InCurrentDir = "^(\\.\\/|[^\\/])[a-zA-Z0-9\\s]+(\\.[a-zA-Z]{1,4})$";
        String filenameRegex_HasAcceptedExtension = "[^\\.]{1,}\\.(text|txt)$"; // White list of valid extensions, we need more ideas ...
        String filenameRegex_HasRelativePath = "\\.\\.";
        //String passwordRegex = "[a-z]*";//"^(?=(.*[a-z].*))(?=(.*[A-Z].*))(?=.*\\\\d.*)(?=.*\\\\W.*)[a-zA-Z0-9\\\\S]{12,56}$";
        char *passwordRegex1 = "[a-z]+";
	char *passwordRegex2 = "[A-Z]+";
	char *passwordRegex3 = "[0-9]+";
	char *passwordRegex4 = "[`~!@#$%^&*()_+=]+";


        if(TEST){
            String nameTestCases[]     = {"", "\0", "\n", "Jhon", " Jhon", "1ll124lk1 1 4l ", "bob", "a", "13", "bob "};
            String numberTestCases[]   = {"", "\0", "\n", "0", " 0", "0 ", " 0 ", "-0", "+0", "123", "-123", "+123", "- 123", "123-", "+0123546789", "+01235467891", " ", "apple"};
            String filenameTestCases[] = {"", "\0", "\n", "file.dog", "file.Txt", "file.txt", "./file/../.txt", "/file.txt", "./file.txt", "../file.txt", "/../file.txt", "./ /"};
            String passwordTestCases[] = {"", "\0", "\n", "abcde", "Slg3k4k23j4Dkj4k23j4kn234jh", ";2l23k23l SFLk#lk429' saf\nsf3 "};

            runRegexTestCases(nameRegex                         , nameTestCases);
            runRegexTestCases(numberRegex                       , numberTestCases);
            runRegexTestCases(filenameRegex_InCurrentDir        , filenameTestCases);
            runRegexTestCases(filenameRegex_HasAcceptedExtension, filenameTestCases);
            runRegexTestCases(filenameRegex_HasRelativePath     , filenameTestCases);
            runRegexTestCases(passwordRegex                     , passwordTestCases);
        }


        /**
         * 1) get first and last name from user
         */
        RegexValidator nameVerifiers[] = {new RegexValidator(nameRegex, true, "You must enter only letters")};
        firstName = getValidString("Enter your first name: ", STRING_INPUT_LENGTH, nameVerifiers);
        lastName  = getValidString("Enter your last name: " , STRING_INPUT_LENGTH, nameVerifiers);


        /**
         * 2) get 2 32 bit ints from user
         */
        RegexValidator numberVerifiers[] = {new RegexValidator(numberRegex, true, "you must only enter digits which may be preceded with an \"+\" or \"-\"")};
        long integerA = getValidInteger("Enter the first 32 bit integer: ", INT_INPUT_LENGTH, numberVerifiers);
        long integerB = getValidInteger("Enter the second 32 bit integer: ",INT_INPUT_LENGTH, numberVerifiers);
        long addResult  = integerA + integerB;
        long multResult = integerA * integerB;

        /**
         * 3) get input/output filename from user
         */
        RegexValidator filenameValidators[] = {
            new RegexValidator(filenameRegex_HasAcceptedExtension, true, "only files with the extensions .txt and .text are allowed"),
            new RegexValidator(filenameRegex_HasRelativePath,      false, "you are not allowed to use relative paths"),
            new RegexValidator(filenameRegex_InCurrentDir,         true, "you may only specify files in the current directory"),
        };
        inputFile = getValidFile("Enter an input file path from the current directory"  , STRING_INPUT_LENGTH, filenameValidators, FileType.Input);
        outputFile = getValidFile("Enter an output file path from the current directory", STRING_INPUT_LENGTH, filenameValidators, FileType.Output);
        writeOutputFile(firstName, lastName, addResult, multResult, inputFile, outputFile);

        /**
         * 4) get password from user
         */
        RegexValidator passwordVerifiers[] = {new RegexValidator(passwordRegex, true, "You must enter between 12 and 56 characters with at least one upper case, one lower chase, one digit, and one symbol")};
        doPasswordThing("Enter a password between 12 and 56 characters that only contains numbers and letters", passwordVerifiers);
    }

    private void doPasswordThing(String prompt, RegexValidator validators[]){
        try {

            boolean isValid = false;
            byte[] salt = new byte[8];
            // Generate salt
            SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
            random.nextBytes(salt);

            // Get the hash of the password
            byte[] originalHash = SecretKeyFactory
                    .getInstance("PBKDF2WithHmacSHA1")
                    .generateSecret(new PBEKeySpec(getValidString(prompt, PWD_INPUT_LENGTH, validators).toCharArray(), salt, 65536, 128))
                    .getEncoded();


            while(!isValid){
                String passwordGuess = getValidString(prompt, PWD_INPUT_LENGTH, validators);

                // Get the hash of the guess
                byte[] guessHash = SecretKeyFactory
                        .getInstance("PBKDF2WithHmacSHA1")
                        .generateSecret(new PBEKeySpec(passwordGuess.toCharArray(), salt, 65536, 128))
                        .getEncoded();

                if(Arrays.equals(originalHash, guessHash)){
                    System.out.println("contratulations, you found the password!!");
                    isValid = true;
                }
                else{
                    System.out.println("- that was the wrong password");
                    isValid = false;
                }
            }// End while
        }// End try
        catch(Exception e){
            System.err.println();
            logError(e.getMessage());
            System.exit(1);
        }
    }// End doPasswordThing

    private String getValidString(String prompt, int inputLength, RegexValidator validators[]){
        if(prompt == null || validators == null)
            throw new NullPointerException();

        boolean isValid = false;
        UserInputResult thisInput = null;

        while(!isValid){
            isValid = true;

            System.out.println(prompt);
            System.out.println(">");
            thisInput = getInput(inputLength);

            if(thisInput.status == UserInputStatus.TooLarge){
                System.out.println("- you Must Enter fewer then " + (inputLength + 1) + " characters");
                isValid = false;
            }
            else if(thisInput.status == UserInputStatus.Empty){
                System.out.println("- you must enter something...");
            }
            else {
                for (RegexValidator thisValidator : validators){
                    if (!thisValidator.validate(thisInput.value)) {
                        isValid = false;
                        System.out.println("- " + thisValidator.failDescription);
                    }
                }
            }
        }// End while(!isValid)
        return thisInput.value;
    }// End getValidString

    private UserInputResult getInput(int length){
        StringBuilder value = new StringBuilder();

        InputStreamReader reader = new InputStreamReader(System.in);
        int copyCount = 0;
        char thisChar = 0;
        boolean exceededBuffer = false;

        try {
            while ((thisChar = (char)reader.read()) != '\n') {
                if(copyCount++ < length)
                    value.append(thisChar);
                else
                    exceededBuffer = true;
            }
        }
        catch(Exception e){
            logError(e.getMessage());
            System.out.println(e.getMessage());
            System.exit(1);
        }
        return new UserInputResult(value.toString(), (exceededBuffer) ? UserInputStatus.TooLarge : (copyCount == 0) ? UserInputStatus.Empty : UserInputStatus.WithinLimits);
    }// End getInput

    long getValidInteger(String prompt, int length, RegexValidator validators[]){
        boolean isValid = false;

        long returnValue = 0;

        while(!isValid) {
            String thisInput = getValidString(prompt, length, validators);
            isValid = true;
            try {
                returnValue = Long.parseLong(thisInput);
                if(returnValue > Integer.MAX_VALUE){
                    System.out.println("- the provided value exceeds the maximum value for a 32 bit signed integer");
                    isValid = false;
                }

                if(returnValue < Integer.MIN_VALUE){
                    System.out.println("- the provided value is less than the minimum value for a 32 bit signed integer");
                    isValid = false;
                }
            }
            catch(NumberFormatException e){ // This should never happen...
                logError(e.getMessage());
                System.out.println("- " + e.getMessage());
                isValid = false;
            }
        }// End while(!isValid)
        return returnValue;
    }// getValidInteger

    File getValidFile(String prompt, int length, RegexValidator validators[], FileType type){
        File validFile = null;

        boolean isValid = false;
        while(!isValid){
            String thisInput = getValidString(prompt, length,validators);

            try {
                Path thisPath = Paths.get(thisInput);
                boolean exists = Files.exists(thisPath);

                isValid = true;
                if (type == FileType.Input) {
                    if(!exists){
                        System.out.println("- you must specify an input file that exists...");
                        isValid = false;
                    }
                    else{
                        BasicFileAttributeView attributes = Files.getFileAttributeView(thisPath, BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
                        FileOwnerAttributeView ownerAttributes = Files.getFileAttributeView(thisPath, FileOwnerAttributeView.class, LinkOption.NOFOLLOW_LINKS);


                        // Make sure we are dealing with a regular file
                        if(!attributes.readAttributes().isRegularFile()){
                            System.out.println("- You must specify a regular file (directories, character/block devices, named pipes, sockets, and symbolic links are not allowed)");
                            isValid = false;
                        }

                        // Make sure the current user is actually the owner of the input file
                        if(!ownerAttributes.getOwner().getName().equals(System.getProperty("user.name"))){
                            System.out.println("- You must specify a file that you own");
                            isValid = false;
                        }

                        // Make sure the current user has read privileges for the specified file
                        validFile = thisPath.toFile();
                        if(!validFile.canRead()){
                            System.out.println("- You must specify a file that you have read privileges to");
                            isValid = false;
                        }
                    }// End else
                } else if (type == FileType.Output) {
                    if(exists){
                        System.out.println("- you must specify a file that doesn't exist already");
                        isValid = false;
                    }
                    else{
                        validFile = thisPath.toFile();
                    }
                }// End else if
            }
            catch(Exception e){
                logError(e.getMessage());
                System.err.println(e.getMessage());
                System.exit(1);
            }
        }
        return validFile;
    }// EndgetValidFile

    private void writeOutputFile(String firstName, String lastName, long addResult, long multResult, File inputFile, File outputFile){
        String newLine = System.lineSeparator();
        String header = firstName + newLine + lastName + newLine + addResult + newLine + multResult + newLine;

        int thisChar = '\0';

        try {
            PrintStream printStream = new PrintStream(outputFile);
            BufferedReader reader = new BufferedReader(new FileReader(inputFile));

            printStream.print(header);

            while((thisChar = reader.read()) != -1){
                printStream.print((char)thisChar);
            }
            printStream.close();
            reader.close();
        }
        catch(Exception e){
            logError(e.getMessage());
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }// End writeOutputFile

    private void logError(String error){
        try {
            PrintStream printStream = new PrintStream(logFile);
            printStream.println((new SimpleDateFormat("yyyy.MM.dd.HH.mm.ss").format(new Date())) + " - " +  error);
        }
        catch(Exception e){
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    private void runRegexTestCases(String regex, String inputs[]){
        System.out.println("---- Test Cases for Regex: " + regex + "---------");
        System.out.println("  Is Match  |  Input  ");
        System.out.println("----------------------");

        RegexValidator thisValidator = new RegexValidator(regex, true, "");

        for(String thisInput: inputs){
            System.out.printf("%12s|%12s",(thisValidator.validate(thisInput) ? "YES" : "NO"), "\"" + thisInput + "\"");
            System.out.println();
        }
        System.out.println();
    }
}
